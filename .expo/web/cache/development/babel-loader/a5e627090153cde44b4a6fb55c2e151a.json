{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport Animated, { block, defined } from \"react-native-reanimated\";\nimport { clamp, max, min } from \"./Math\";\nimport { decompose2d } from \"./Matrix3\";\nvar Value = Animated.Value,\n    set = Animated.set,\n    add = Animated.add,\n    multiply = Animated.multiply,\n    cond = Animated.cond,\n    eq = Animated.eq,\n    abs = Animated.abs,\n    sub = Animated.sub,\n    not = Animated.not,\n    lessThan = Animated.lessThan,\n    greaterThan = Animated.greaterThan,\n    divide = Animated.divide,\n    modulo = Animated.modulo,\n    proc = Animated.proc;\nexport var mix = proc(function (value, x, y) {\n  return add(x, multiply(value, sub(y, x)));\n});\nexport var step = proc(function (value, edge) {\n  return lessThan(value, edge);\n});\nexport var smoothstep = proc(function (value, edge0, edge1) {\n  var t = clamp(divide(sub(value, edge0), sub(edge1, edge0)), 0, 1);\n  return multiply(t, t, sub(3, multiply(2, t)));\n});\nexport var tween2d = function tween2d(value, t1, t2) {\n  var d1 = decompose2d(t1);\n  var d2 = decompose2d(t2);\n  var translateX = mix(value, d1[0].translateX, d2[0].translateX);\n  var translateY = mix(value, d1[1].translateY, d2[1].translateY);\n  var skewX = mix(value, d1[2].rotateZ, d2[2].rotateZ);\n  var scaleX = mix(value, d1[3].scaleX, d2[3].scaleX);\n  var scaleY = mix(value, d1[4].scaleY, d2[4].scaleY);\n  var rotateZ = mix(value, d1[5].rotateZ, d2[5].rotateZ);\n  return [{\n    translateX: translateX\n  }, {\n    translateY: translateY\n  }, {\n    rotateZ: skewX\n  }, {\n    scaleX: scaleX\n  }, {\n    scaleY: scaleY\n  }, {\n    rotateZ: rotateZ\n  }];\n};\nexport var diff = function diff(v) {\n  var stash = new Value(0);\n  var prev = new Value();\n  return block([set(stash, cond(defined(prev), sub(v, prev), 0)), set(prev, v), stash]);\n};\nexport var diffClamp = function diffClamp(a, minVal, maxVal) {\n  var value = new Value();\n  return set(value, min(max(add(cond(defined(value), value, a), diff(a)), minVal), maxVal));\n};\nexport var moving = function moving(position) {\n  var minPositionDelta = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1e-3;\n  var emptyFrameThreshold = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 5;\n  var delta = diff(position);\n  var noMovementFrames = new Value(0);\n  return cond(lessThan(abs(delta), minPositionDelta), [set(noMovementFrames, add(noMovementFrames, 1)), not(greaterThan(noMovementFrames, emptyFrameThreshold))], [set(noMovementFrames, 0), 1]);\n};\nexport var snapPoint = function snapPoint(value, velocity, points) {\n  var point = add(value, multiply(0.2, velocity));\n\n  var diffPoint = function diffPoint(p) {\n    return abs(sub(point, p));\n  };\n\n  var deltas = points.map(function (p) {\n    return diffPoint(p);\n  });\n  var minDelta = min.apply(void 0, _toConsumableArray(deltas));\n  return points.reduce(function (acc, p) {\n    return cond(eq(diffPoint(p), minDelta), p, acc);\n  }, new Value());\n};\nexport var addTo = proc(function (value, node) {\n  return set(value, add(value, node));\n});\nexport var subTo = proc(function (value, node) {\n  return set(value, sub(value, node));\n});\nexport var multiplyTo = proc(function (value, node) {\n  return set(value, multiply(value, node));\n});\nexport var divideTo = proc(function (value, node) {\n  return set(value, divide(value, node));\n});\nexport var moduloTo = proc(function (value, node) {\n  return set(value, modulo(value, node));\n});","map":{"version":3,"sources":["Animations.ts"],"names":["Value","set","add","multiply","cond","eq","abs","sub","not","lessThan","greaterThan","divide","modulo","proc","Animated","mix","step","smoothstep","t","clamp","tween2d","d1","decompose2d","d2","translateX","translateY","skewX","scaleX","scaleY","rotateZ","diff","stash","prev","block","defined","diffClamp","value","min","max","moving","minPositionDelta","emptyFrameThreshold","delta","noMovementFrames","snapPoint","point","diffPoint","deltas","points","minDelta","addTo","subTo","multiplyTo","divideTo","moduloTo"],"mappings":"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","sourcesContent":["import Animated, { block, defined } from \"react-native-reanimated\";\n\nimport { clamp, max, min } from \"./Math\";\nimport { Matrix3, Transforms2d, decompose2d } from \"./Matrix3\";\n\nconst {\n  Value,\n  set,\n  add,\n  multiply,\n  cond,\n  eq,\n  abs,\n  sub,\n  not,\n  lessThan,\n  greaterThan,\n  divide,\n  modulo,\n  proc,\n} = Animated;\n\nexport type SpringConfig = Partial<Omit<Animated.SpringConfig, \"toValue\">>;\nexport type TimingConfig = Partial<Omit<Animated.TimingConfig, \"toValue\">>;\n\nexport const mix = proc(\n  (\n    value: Animated.Adaptable<number>,\n    x: Animated.Adaptable<number>,\n    y: Animated.Adaptable<number>\n  ) => add(x, multiply(value, sub(y, x)))\n);\n\nexport const step = proc(\n  (value: Animated.Adaptable<number>, edge: Animated.Adaptable<number>) =>\n    lessThan(value, edge)\n);\n\nexport const smoothstep = proc(\n  (\n    value: Animated.Adaptable<number>,\n    edge0: Animated.Adaptable<number>,\n    edge1: Animated.Adaptable<number>\n  ) => {\n    const t = clamp(divide(sub(value, edge0), sub(edge1, edge0)), 0, 1);\n    return multiply(t, t, sub(3, multiply(2, t)));\n  }\n);\n\nexport const tween2d = (\n  value: Animated.Node<number>,\n  t1: Matrix3 | Transforms2d,\n  t2: Matrix3 | Transforms2d\n) => {\n  const d1 = decompose2d(t1);\n  const d2 = decompose2d(t2);\n  const translateX = mix(value, d1[0].translateX, d2[0].translateX);\n  const translateY = mix(value, d1[1].translateY, d2[1].translateY);\n  const skewX = mix(value, d1[2].rotateZ, d2[2].rotateZ);\n  const scaleX = mix(value, d1[3].scaleX, d2[3].scaleX);\n  const scaleY = mix(value, d1[4].scaleY, d2[4].scaleY);\n  const rotateZ = mix(value, d1[5].rotateZ, d2[5].rotateZ);\n  return [\n    { translateX },\n    { translateY },\n    { rotateZ: skewX },\n    { scaleX },\n    { scaleY },\n    { rotateZ },\n  ] as const;\n};\n\n// currently diffClamp() from reanimated seems currently buggy because of proc()\nexport const diff = (v: Animated.Node<number>) => {\n  const stash = new Value(0);\n  const prev = new Value<number>();\n  return block([\n    set(stash, cond(defined(prev), sub(v, prev), 0)),\n    set(prev, v),\n    stash,\n  ]);\n};\n\nexport const diffClamp = (\n  a: Animated.Node<number>,\n  minVal: Animated.Adaptable<number>,\n  maxVal: Animated.Adaptable<number>\n) => {\n  const value = new Value<number>();\n  return set(\n    value,\n    min(max(add(cond(defined(value), value, a), diff(a)), minVal), maxVal)\n  );\n};\n\nexport const moving = (\n  position: Animated.Node<number>,\n  minPositionDelta = 1e-3,\n  emptyFrameThreshold = 5\n) => {\n  const delta = diff(position);\n  const noMovementFrames = new Value(0);\n  return cond(\n    lessThan(abs(delta), minPositionDelta),\n    [\n      set(noMovementFrames, add(noMovementFrames, 1)),\n      not(greaterThan(noMovementFrames, emptyFrameThreshold)),\n    ],\n    [set(noMovementFrames, 0), 1]\n  );\n};\n\nexport const snapPoint = (\n  value: Animated.Adaptable<number>,\n  velocity: Animated.Adaptable<number>,\n  points: Animated.Adaptable<number>[]\n) => {\n  const point = add(value, multiply(0.2, velocity));\n  const diffPoint = (p: Animated.Adaptable<number>) => abs(sub(point, p));\n  const deltas = points.map((p) => diffPoint(p));\n  const minDelta = min(...deltas);\n  return points.reduce(\n    (acc, p) => cond(eq(diffPoint(p), minDelta), p, acc),\n    new Value()\n  ) as Animated.Node<number>;\n};\n\nexport const addTo = proc(\n  (value: Animated.Value<number>, node: Animated.Adaptable<number>) =>\n    set(value, add(value, node))\n);\n\nexport const subTo = proc(\n  (value: Animated.Value<number>, node: Animated.Adaptable<number>) =>\n    set(value, sub(value, node))\n);\n\nexport const multiplyTo = proc(\n  (value: Animated.Value<number>, node: Animated.Adaptable<number>) =>\n    set(value, multiply(value, node))\n);\n\nexport const divideTo = proc(\n  (value: Animated.Value<number>, node: Animated.Adaptable<number>) =>\n    set(value, divide(value, node))\n);\n\nexport const moduloTo = proc(\n  (value: Animated.Value<number>, node: Animated.Adaptable<number>) =>\n    set(value, modulo(value, node))\n);\n"]},"metadata":{},"sourceType":"module"}