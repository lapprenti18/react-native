{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _taggedTemplateLiteralLoose from \"@babel/runtime/helpers/taggedTemplateLiteralLoose\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/objectWithoutProperties\";\nimport _toArray from \"@babel/runtime/helpers/toArray\";\n\nfunction _templateObject2() {\n  var data = _taggedTemplateLiteralLoose([\"M\", \",\", \" \"]);\n\n  _templateObject2 = function _templateObject2() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject() {\n  var data = _taggedTemplateLiteralLoose([\"\", \"C\", \",\", \" \", \",\", \" \", \",\", \"\"]);\n\n  _templateObject = function _templateObject() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nimport Animated from \"react-native-reanimated\";\nimport parseSVG from \"parse-svg-path\";\nimport absSVG from \"abs-svg-path\";\nimport normalizeSVG from \"normalize-svg-path\";\nimport interpolateNode from \"react-native-reanimated/src/derived/interpolate\";\nimport { get } from \"./Array\";\nimport { string } from \"./String\";\nimport { cubicBezier } from \"./Math\";\nimport cubicBezierLength from \"./bezier/CubicBezierLength\";\nimport cubicBezierSolve from \"./bezier/CubicBezierSolve\";\nvar Value = Animated.Value,\n    lessOrEq = Animated.lessOrEq,\n    greaterOrEq = Animated.greaterOrEq,\n    and = Animated.and,\n    cond = Animated.cond,\n    multiply = Animated.multiply,\n    lessThan = Animated.lessThan,\n    concat = Animated.concat,\n    add = Animated.add;\nvar MX = 1;\nvar MY = 2;\nvar CX1 = 1;\nvar CY1 = 2;\nvar CX2 = 3;\nvar CY2 = 4;\nvar CX = 5;\nvar CY = 6;\nexport var parsePath = function parsePath(d) {\n  var _normalizeSVG = normalizeSVG(absSVG(parseSVG(d))),\n      _normalizeSVG2 = _toArray(_normalizeSVG),\n      move = _normalizeSVG2[0],\n      curves = _normalizeSVG2.slice(1);\n\n  var parts = curves.map(function (curve, index) {\n    var prevCurve = curves[index - 1];\n    var p0 = index === 0 ? {\n      x: move[MX],\n      y: move[MY]\n    } : {\n      x: prevCurve[CX],\n      y: prevCurve[CY]\n    };\n    var p1 = {\n      x: curve[CX1],\n      y: curve[CY1]\n    };\n    var p2 = {\n      x: curve[CX2],\n      y: curve[CY2]\n    };\n    var p3 = {\n      x: curve[CX],\n      y: curve[CY]\n    };\n    var length = cubicBezierLength(p0, p1, p2, p3);\n    return {\n      p0: p0,\n      p1: p1,\n      p2: p2,\n      p3: p3,\n      length: length\n    };\n  });\n  var segments = parts.map(function (part, index) {\n    var start = parts.slice(0, index).reduce(function (acc, p) {\n      return acc + p.length;\n    }, 0);\n    var end = start + part.length;\n    return {\n      start: start,\n      end: end,\n      p0x: part.p0.x,\n      p3x: part.p3.x\n    };\n  });\n  return {\n    segments: segments,\n    totalLength: parts.reduce(function (acc, part) {\n      return acc + part.length;\n    }, 0),\n    length: parts.map(function (part) {\n      return part.length;\n    }),\n    start: segments.map(function (segment) {\n      return segment.start;\n    }),\n    end: segments.map(function (segment) {\n      return segment.end;\n    }),\n    p0x: parts.map(function (part) {\n      return part.p0.x;\n    }),\n    p0y: parts.map(function (part) {\n      return part.p0.y;\n    }),\n    p1x: parts.map(function (part) {\n      return part.p1.x;\n    }),\n    p1y: parts.map(function (part) {\n      return part.p1.y;\n    }),\n    p2x: parts.map(function (part) {\n      return part.p2.x;\n    }),\n    p2y: parts.map(function (part) {\n      return part.p2.y;\n    }),\n    p3x: parts.map(function (part) {\n      return part.p3.x;\n    }),\n    p3y: parts.map(function (part) {\n      return part.p3.y;\n    })\n  };\n};\nexport var getPointAtLength = function getPointAtLength(path, length) {\n  var notFound = new Value(-1);\n  var index = path.segments.reduce(function (acc, p, i) {\n    return cond(and(greaterOrEq(length, p.start), lessOrEq(length, p.end)), i, acc);\n  }, notFound);\n  var start = get(path.start, index);\n  var end = get(path.end, index);\n  var p0x = get(path.p0x, index);\n  var p1x = get(path.p1x, index);\n  var p2x = get(path.p2x, index);\n  var p3x = get(path.p3x, index);\n  var p0y = get(path.p0y, index);\n  var p1y = get(path.p1y, index);\n  var p2y = get(path.p2y, index);\n  var p3y = get(path.p3y, index);\n  var t = interpolateNode(length, {\n    inputRange: [start, end],\n    outputRange: [0, 1]\n  });\n  return {\n    x: cubicBezier(t, p0x, p1x, p2x, p3x),\n    y: cubicBezier(t, p0y, p1y, p2y, p3y)\n  };\n};\nexport var interpolatePath = function interpolatePath(value, _ref) {\n  var inputRange = _ref.inputRange,\n      outputRange = _ref.outputRange,\n      config = _objectWithoutProperties(_ref, [\"inputRange\", \"outputRange\"]);\n\n  var paths = outputRange.map(function (path) {\n    return typeof path === \"string\" ? parsePath(path) : path;\n  });\n\n  var _paths = _slicedToArray(paths, 1),\n      path = _paths[0];\n\n  var commands = path.segments.map(function (_, index) {\n    var interpolatePoint = function interpolatePoint(point) {\n      return interpolateNode(value, _objectSpread({\n        inputRange: inputRange,\n        outputRange: paths.map(function (p) {\n          return p[point][index];\n        })\n      }, config));\n    };\n\n    var mx = interpolatePoint(\"p0x\");\n    var my = interpolatePoint(\"p0y\");\n    var p1x = interpolatePoint(\"p1x\");\n    var p1y = interpolatePoint(\"p1y\");\n    var p2x = interpolatePoint(\"p2x\");\n    var p2y = interpolatePoint(\"p2y\");\n    var p3x = interpolatePoint(\"p3x\");\n    var p3y = interpolatePoint(\"p3y\");\n    return string(_templateObject(), index === 0 ? string(_templateObject2(), mx, my) : \"\", p1x, p1y, p2x, p2y, p3x, p3y);\n  });\n  return concat.apply(void 0, _toConsumableArray(commands));\n};\nexport var bInterpolatePath = function bInterpolatePath(value, path1, path2) {\n  return interpolatePath(value, {\n    inputRange: [0, 1],\n    outputRange: [path1, path2]\n  });\n};\nexport var getLengthAtX = function getLengthAtX(path, x) {\n  var notFound = new Value(-1);\n  var index = path.segments.reduce(function (acc, p, i) {\n    return cond(and(greaterOrEq(x, p.p0x), lessOrEq(x, p.p3x)), i, acc);\n  }, notFound);\n  var p0 = get(path.p0x, index);\n  var p1 = get(path.p1x, index);\n  var p2 = get(path.p2x, index);\n  var p3 = get(path.p3x, index);\n  var t = cubicBezierSolve(p0, p1, p2, p3);\n  var length = get(path.length, index);\n  var start = add.apply(void 0, _toConsumableArray(path.length.map(function (l, i) {\n    return cond(lessThan(i, index), l, 0);\n  })));\n  return add(start, multiply(t, length));\n};","map":{"version":3,"sources":["SVG.ts"],"names":["Value","lessOrEq","greaterOrEq","and","cond","multiply","lessThan","concat","add","Animated","MX","MY","CX1","CY1","CX2","CY2","CX","CY","parsePath","move","curves","normalizeSVG","absSVG","parseSVG","parts","prevCurve","index","p0","x","y","p1","curve","p2","p3","length","cubicBezierLength","segments","start","acc","p","end","part","p0x","p3x","totalLength","segment","p0y","p1x","p1y","p2x","p2y","p3y","getPointAtLength","notFound","path","get","t","interpolateNode","inputRange","outputRange","cubicBezier","interpolatePath","config","paths","commands","interpolatePoint","mx","my","string","bInterpolatePath","getLengthAtX","cubicBezierSolve"],"mappings":"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","sourcesContent":["import Animated from \"react-native-reanimated\";\nimport parseSVG from \"parse-svg-path\";\nimport absSVG from \"abs-svg-path\";\nimport normalizeSVG from \"normalize-svg-path\";\nimport interpolateNode from \"react-native-reanimated/src/derived/interpolate\";\n\nimport { get } from \"./Array\";\nimport { string } from \"./String\";\nimport { cubicBezier } from \"./Math\";\nimport cubicBezierLength from \"./bezier/CubicBezierLength\";\nimport cubicBezierSolve from \"./bezier/CubicBezierSolve\";\n\nconst {\n  Value,\n  lessOrEq,\n  greaterOrEq,\n  and,\n  cond,\n  multiply,\n  lessThan,\n  concat,\n  add,\n} = Animated;\n\n// const COMMAND = 0;\nconst MX = 1;\nconst MY = 2;\nconst CX1 = 1;\nconst CY1 = 2;\nconst CX2 = 3;\nconst CY2 = 4;\nconst CX = 5;\nconst CY = 6;\n\ntype SVGMoveCommand = [\"M\", number, number];\ntype SVGCurveCommand = [\"C\", number, number, number, number, number, number];\ntype SVGNormalizedCommands = [SVGMoveCommand, ...SVGCurveCommand[]];\ntype BezierPoint =\n  | \"p0x\"\n  | \"p0y\"\n  | \"p1x\"\n  | \"p1y\"\n  | \"p2x\"\n  | \"p2y\"\n  | \"p3x\"\n  | \"p3y\";\n\ninterface Point {\n  x: number;\n  y: number;\n}\n\ninterface BezierCubicCurve {\n  length: number;\n  p0: Point;\n  p1: Point;\n  p2: Point;\n  p3: Point;\n}\n\nexport interface PathInterpolationConfig {\n  inputRange: readonly Animated.Adaptable<number>[];\n  outputRange: readonly (ReanimatedPath | string)[];\n  extrapolate?: Animated.Extrapolate;\n  extrapolateLeft?: Animated.Extrapolate;\n  extrapolateRight?: Animated.Extrapolate;\n}\n\nexport interface ReanimatedPath {\n  totalLength: number;\n  segments: { start: number; end: number; p0x: number; p3x: number }[];\n  length: number[];\n  start: number[];\n  end: number[];\n  p0x: number[];\n  p0y: number[];\n  p1x: number[];\n  p1y: number[];\n  p2x: number[];\n  p2y: number[];\n  p3x: number[];\n  p3y: number[];\n}\n\nexport const parsePath = (d: string): ReanimatedPath => {\n  const [move, ...curves]: SVGNormalizedCommands = normalizeSVG(\n    absSVG(parseSVG(d))\n  );\n  const parts: BezierCubicCurve[] = curves.map((curve, index) => {\n    const prevCurve = curves[index - 1];\n    const p0 =\n      index === 0\n        ? { x: move[MX], y: move[MY] }\n        : { x: prevCurve[CX], y: prevCurve[CY] };\n    const p1 = { x: curve[CX1], y: curve[CY1] };\n    const p2 = { x: curve[CX2], y: curve[CY2] };\n    const p3 = { x: curve[CX], y: curve[CY] };\n    const length = cubicBezierLength(p0, p1, p2, p3);\n    return {\n      p0,\n      p1,\n      p2,\n      p3,\n      length,\n    };\n  });\n  const segments = parts.map((part, index) => {\n    const start = parts.slice(0, index).reduce((acc, p) => acc + p.length, 0);\n    const end = start + part.length;\n    return {\n      start,\n      end,\n      p0x: part.p0.x,\n      p3x: part.p3.x,\n    };\n  });\n  return {\n    segments,\n    totalLength: parts.reduce((acc, part) => acc + part.length, 0),\n    length: parts.map((part) => part.length),\n    start: segments.map((segment) => segment.start),\n    end: segments.map((segment) => segment.end),\n    p0x: parts.map((part) => part.p0.x),\n    p0y: parts.map((part) => part.p0.y),\n    p1x: parts.map((part) => part.p1.x),\n    p1y: parts.map((part) => part.p1.y),\n    p2x: parts.map((part) => part.p2.x),\n    p2y: parts.map((part) => part.p2.y),\n    p3x: parts.map((part) => part.p3.x),\n    p3y: parts.map((part) => part.p3.y),\n  };\n};\n\nexport const getPointAtLength = (\n  path: ReanimatedPath,\n  length: Animated.Adaptable<number>\n): { x: Animated.Node<number>; y: Animated.Node<number> } => {\n  const notFound: Animated.Node<number> = new Value(-1);\n  const index = path.segments.reduce(\n    (acc, p, i) =>\n      cond(and(greaterOrEq(length, p.start), lessOrEq(length, p.end)), i, acc),\n    notFound\n  );\n  const start = get(path.start, index);\n  const end = get(path.end, index);\n\n  const p0x = get(path.p0x, index);\n  const p1x = get(path.p1x, index);\n  const p2x = get(path.p2x, index);\n  const p3x = get(path.p3x, index);\n\n  const p0y = get(path.p0y, index);\n  const p1y = get(path.p1y, index);\n  const p2y = get(path.p2y, index);\n  const p3y = get(path.p3y, index);\n  const t = interpolateNode(length, {\n    inputRange: [start, end],\n    outputRange: [0, 1],\n  });\n  return {\n    x: cubicBezier(t, p0x, p1x, p2x, p3x),\n    y: cubicBezier(t, p0y, p1y, p2y, p3y),\n  };\n};\n\nexport const interpolatePath = (\n  value: Animated.Adaptable<number>,\n  { inputRange, outputRange, ...config }: PathInterpolationConfig\n): Animated.Node<string> => {\n  const paths = outputRange.map((path) =>\n    typeof path === \"string\" ? parsePath(path) : path\n  );\n  const [path] = paths;\n  const commands = path.segments.map((_, index) => {\n    const interpolatePoint = (point: BezierPoint) =>\n      interpolateNode(value, {\n        inputRange,\n        outputRange: paths.map((p) => p[point][index]),\n        ...config,\n      });\n\n    const mx = interpolatePoint(\"p0x\");\n    const my = interpolatePoint(\"p0y\");\n\n    const p1x = interpolatePoint(\"p1x\");\n    const p1y = interpolatePoint(\"p1y\");\n\n    const p2x = interpolatePoint(\"p2x\");\n    const p2y = interpolatePoint(\"p2y\");\n\n    const p3x = interpolatePoint(\"p3x\");\n    const p3y = interpolatePoint(\"p3y\");\n\n    return string`${\n      index === 0 ? string`M${mx},${my} ` : \"\"\n    }C${p1x},${p1y} ${p2x},${p2y} ${p3x},${p3y}`;\n  });\n  return concat(...commands);\n};\n\nexport const bInterpolatePath = (\n  value: Animated.Value<number>,\n  path1: ReanimatedPath | string,\n  path2: ReanimatedPath | string\n): Animated.Node<string> =>\n  interpolatePath(value, {\n    inputRange: [0, 1],\n    outputRange: [path1, path2],\n  });\n\n// https://pomax.github.io/bezierinfo/#yforx\nexport const getLengthAtX = (\n  path: ReanimatedPath,\n  x: Animated.Adaptable<number>\n): Animated.Node<number> => {\n  const notFound: Animated.Node<number> = new Value(-1);\n  const index = path.segments.reduce(\n    (acc, p, i) => cond(and(greaterOrEq(x, p.p0x), lessOrEq(x, p.p3x)), i, acc),\n    notFound\n  );\n  const p0 = get(path.p0x, index);\n  const p1 = get(path.p1x, index);\n  const p2 = get(path.p2x, index);\n  const p3 = get(path.p3x, index);\n  const t = cubicBezierSolve(p0, p1, p2, p3);\n  const length = get(path.length, index);\n  /* eslint-disable @typescript-eslint/no-explicit-any */\n  const start = add(\n    ...(path.length.map((l, i) => cond(lessThan(i, index), l, 0)) as [\n      any,\n      any,\n      ...any[]\n    ])\n  );\n  /* eslint-enable @typescript-eslint/no-explicit-any */\n  return add(start, multiply(t, length));\n};\n"]},"metadata":{},"sourceType":"module"}