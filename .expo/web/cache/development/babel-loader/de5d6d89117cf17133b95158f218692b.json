{"ast":null,"code":"import Animated, { interpolate } from \"react-native-reanimated\";\nimport parseSVG from \"parse-svg-path\";\nimport absSVG from \"abs-svg-path\";\nimport normalizeSVG from \"normalize-svg-path\";\nimport { cartesian2Polar } from \"./Coordinates\";\nimport { cubicBezierYForX } from \"./Math\";\nexport var serialize = function serialize(path) {\n  \"worklet\";\n\n  return \"M\" + path.move.x + \",\" + path.move.y + \" \" + path.curves.map(function (c) {\n    return \"C\" + c.c1.x + \",\" + c.c1.y + \" \" + c.c2.x + \",\" + c.c2.y + \" \" + c.to.x + \",\" + c.to.y;\n  }).join(\" \") + (path.close ? \"Z\" : \"\");\n};\nexport var parse = function parse(d) {\n  var segments = normalizeSVG(absSVG(parseSVG(d)));\n  var path = createPath({\n    x: segments[0][1],\n    y: segments[0][2]\n  });\n  segments.forEach(function (segment) {\n    if (segment[0] === \"Z\") {\n      close(path);\n    } else if (segment[0] === \"C\") {\n      addCurve(path, {\n        c1: {\n          x: segment[1],\n          y: segment[2]\n        },\n        c2: {\n          x: segment[3],\n          y: segment[4]\n        },\n        to: {\n          x: segment[5],\n          y: segment[6]\n        }\n      });\n    }\n  });\n  return path;\n};\nexport var interpolatePath = function interpolatePath(value, inputRange, outputRange) {\n  \"worklet\";\n\n  var extrapolate = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Animated.Extrapolate.CLAMP;\n  var path = {\n    move: {\n      x: interpolate(value, inputRange, outputRange.map(function (p) {\n        return p.move.x;\n      }), extrapolate),\n      y: interpolate(value, inputRange, outputRange.map(function (p) {\n        return p.move.y;\n      }), extrapolate)\n    },\n    curves: outputRange[0].curves.map(function (_, index) {\n      return {\n        c1: {\n          x: interpolate(value, inputRange, outputRange.map(function (p) {\n            return p.curves[index].c1.x;\n          }), extrapolate),\n          y: interpolate(value, inputRange, outputRange.map(function (p) {\n            return p.curves[index].c1.y;\n          }), extrapolate)\n        },\n        c2: {\n          x: interpolate(value, inputRange, outputRange.map(function (p) {\n            return p.curves[index].c2.x;\n          }), extrapolate),\n          y: interpolate(value, inputRange, outputRange.map(function (p) {\n            return p.curves[index].c2.y;\n          }), extrapolate)\n        },\n        to: {\n          x: interpolate(value, inputRange, outputRange.map(function (p) {\n            return p.curves[index].to.x;\n          }), extrapolate),\n          y: interpolate(value, inputRange, outputRange.map(function (p) {\n            return p.curves[index].to.y;\n          }), extrapolate)\n        }\n      };\n    }),\n    close: outputRange[0].close\n  };\n  return serialize(path);\n};\nexport var mixPath = function mixPath(value, p1, p2) {\n  \"worklet\";\n\n  var extrapolate = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Animated.Extrapolate.CLAMP;\n  return interpolatePath(value, [0, 1], [p1, p2], extrapolate);\n};\nexport var createPath = function createPath(move) {\n  \"worklet\";\n\n  return {\n    move: move,\n    curves: [],\n    close: false\n  };\n};\nexport var addArc = function addArc(path, corner, to) {\n  \"worklet\";\n\n  var last = path.curves[path.curves.length - 1];\n  var from = last ? last.to : path.move;\n  var arc = 9 / 16;\n  path.curves.push({\n    c1: {\n      x: (corner.x - from.x) * arc + from.x,\n      y: (corner.y - from.y) * arc + from.y\n    },\n    c2: {\n      x: (corner.x - to.x) * arc + to.x,\n      y: (corner.y - to.y) * arc + to.y\n    },\n    to: to\n  });\n};\nexport var addCurve = function addCurve(path, c) {\n  \"worklet\";\n\n  path.curves.push({\n    c1: c.c1,\n    c2: c.c2,\n    to: c.to\n  });\n};\nexport var addLine = function addLine(path, to) {\n  \"worklet\";\n\n  var last = path.curves[path.curves.length - 1];\n  var from = last ? last.to : path.move;\n  path.curves.push({\n    c1: from,\n    c2: to,\n    to: to\n  });\n};\nexport var addQuadraticCurve = function addQuadraticCurve(path, cp, to) {\n  \"worklet\";\n\n  var last = path.curves[path.curves.length - 1];\n  var from = last ? last.to : path.move;\n  path.curves.push({\n    c1: {\n      x: from.x / 3 + 2 / 3 * cp.x,\n      y: from.y / 3 + 2 / 3 * cp.y\n    },\n    c2: {\n      x: to.x / 3 + 2 / 3 * cp.x,\n      y: to.y / 3 + 2 / 3 * cp.y\n    },\n    to: to\n  });\n};\nexport var close = function close(path) {\n  \"worklet\";\n\n  path.close = true;\n};\n\nvar curveIsFound = function curveIsFound(c) {\n  \"worklet\";\n\n  return c.curve !== null;\n};\n\nexport var selectCurve = function selectCurve(path, x) {\n  \"worklet\";\n\n  var result = {\n    from: path.move,\n    curve: null\n  };\n\n  for (var i = 0; i < path.curves.length; i++) {\n    var c = path.curves[i];\n    var contains = result.from.x > c.to.x ? x >= c.to.x && x <= result.from.x : x >= result.from.x && x <= c.to.x;\n\n    if (contains) {\n      result.curve = c;\n      break;\n    }\n\n    result.from = c.to;\n  }\n\n  if (!curveIsFound(result)) {\n    throw new Error(\"No curve found at \" + x);\n  }\n\n  return result;\n};\nexport var getYForX = function getYForX(path, x) {\n  \"worklet\";\n\n  var precision = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 2;\n  var c = selectCurve(path, x);\n  return cubicBezierYForX(x, c.from, c.curve.c1, c.curve.c2, c.curve.to, precision);\n};\n\nvar controlPoint = function controlPoint(current, previous, next, reverse, smoothing) {\n  \"worklet\";\n\n  var p = previous || current;\n  var n = next || current;\n  var lengthX = n.x - p.x;\n  var lengthY = n.y - p.y;\n  var o = cartesian2Polar({\n    x: lengthX,\n    y: lengthY\n  });\n  var angle = o.theta + (reverse ? Math.PI : 0);\n  var length = o.radius * smoothing;\n  var x = current.x + Math.cos(angle) * length;\n  var y = current.y + Math.sin(angle) * length;\n  return {\n    x: x,\n    y: y\n  };\n};\n\nvar exhaustiveCheck = function exhaustiveCheck(a) {\n  throw new Error(\"Unexhaustive handling for \" + a);\n};\n\nexport var curveLines = function curveLines(points, smoothing, strategy) {\n  \"worklet\";\n\n  var path = createPath(points[0]);\n\n  for (var i = 0; i < points.length; i++) {\n    if (i === 0) {\n      continue;\n    }\n\n    var point = points[i];\n    var next = points[i + 1];\n    var prev = points[i - 1];\n    var cps = controlPoint(prev, points[i - 2], point, false, smoothing);\n    var cpe = controlPoint(point, prev, next, true, smoothing);\n\n    switch (strategy) {\n      case \"simple\":\n        var cp = {\n          x: (cps.x + cpe.x) / 2,\n          y: (cps.y + cpe.y) / 2\n        };\n        addQuadraticCurve(path, cp, point);\n        break;\n\n      case \"bezier\":\n        var p0 = points[i - 2] || prev;\n        var p1 = points[i - 1];\n        var cp1x = (2 * p0.x + p1.x) / 3;\n        var cp1y = (2 * p0.y + p1.y) / 3;\n        var cp2x = (p0.x + 2 * p1.x) / 3;\n        var cp2y = (p0.y + 2 * p1.y) / 3;\n        var cp3x = (p0.x + 4 * p1.x + point.x) / 6;\n        var cp3y = (p0.y + 4 * p1.y + point.y) / 6;\n        path.curves.push({\n          c1: {\n            x: cp1x,\n            y: cp1y\n          },\n          c2: {\n            x: cp2x,\n            y: cp2y\n          },\n          to: {\n            x: cp3x,\n            y: cp3y\n          }\n        });\n\n        if (i === points.length - 1) {\n          path.curves.push({\n            to: points[points.length - 1],\n            c1: points[points.length - 1],\n            c2: points[points.length - 1]\n          });\n        }\n\n        break;\n\n      case \"complex\":\n        path.curves.push({\n          to: point,\n          c1: cps,\n          c2: cpe\n        });\n        break;\n\n      default:\n        exhaustiveCheck(strategy);\n    }\n  }\n\n  return path;\n};","map":{"version":3,"sources":["Paths.ts"],"names":["serialize","path","c","parse","segments","normalizeSVG","absSVG","parseSVG","createPath","x","y","segment","close","addCurve","c1","c2","to","interpolatePath","extrapolate","Animated","CLAMP","move","interpolate","outputRange","p","curves","mixPath","addArc","last","from","arc","corner","addLine","addQuadraticCurve","cp","curveIsFound","selectCurve","result","curve","i","contains","getYForX","precision","cubicBezierYForX","controlPoint","previous","n","next","lengthX","lengthY","o","cartesian2Polar","angle","reverse","Math","length","current","exhaustiveCheck","curveLines","points","point","prev","cps","cpe","p0","p1","cp1x","cp1y","cp2x","cp2y","cp3x","cp3y"],"mappings":"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","sourcesContent":["import Animated, { interpolate } from \"react-native-reanimated\";\nimport parseSVG from \"parse-svg-path\";\nimport absSVG from \"abs-svg-path\";\nimport normalizeSVG from \"normalize-svg-path\";\n\nimport { Vector } from \"./Vectors\";\nimport { cartesian2Polar } from \"./Coordinates\";\nimport { cubicBezierYForX } from \"./Math\";\n\ntype SVGCloseCommand = [\"Z\"];\ntype SVGMoveCommand = [\"M\", number, number];\ntype SVGCurveCommand = [\"C\", number, number, number, number, number, number];\ntype SVGNormalizedCommands = [\n  SVGMoveCommand,\n  ...(SVGCurveCommand | SVGCloseCommand)[]\n];\n\ninterface Curve {\n  to: Vector;\n  c1: Vector;\n  c2: Vector;\n}\n\nexport type Path = {\n  move: Vector;\n  curves: Curve[];\n  close: boolean;\n};\n\n/**\n * @summary Serialize a path into an SVG path string\n */\nexport const serialize = (path: Path) => {\n  \"worklet\";\n  return `M${path.move.x},${path.move.y} ${path.curves\n    .map((c) => `C${c.c1.x},${c.c1.y} ${c.c2.x},${c.c2.y} ${c.to.x},${c.to.y}`)\n    .join(\" \")}${path.close ? \"Z\" : \"\"}`;\n};\n\n/**\n * @description ⚠️ this function cannot run on the UI thread. It must be executed on the JS thread\n * @summary Parse an SVG path into a sequence of Bèzier curves.\n * The SVG is normalized to have absolute values and to be approximated to a sequence of Bèzier curves.\n */\nexport const parse = (d: string): Path => {\n  const segments: SVGNormalizedCommands = normalizeSVG(absSVG(parseSVG(d)));\n  const path = createPath({ x: segments[0][1], y: segments[0][2] });\n  segments.forEach((segment) => {\n    if (segment[0] === \"Z\") {\n      close(path);\n    } else if (segment[0] === \"C\") {\n      addCurve(path, {\n        c1: {\n          x: segment[1],\n          y: segment[2],\n        },\n        c2: {\n          x: segment[3],\n          y: segment[4],\n        },\n        to: {\n          x: segment[5],\n          y: segment[6],\n        },\n      });\n    }\n  });\n  return path;\n};\n\n/**\n * @summary Interpolate between paths.\n */\nexport const interpolatePath = (\n  value: number,\n  inputRange: number[],\n  outputRange: Path[],\n  extrapolate = Animated.Extrapolate.CLAMP\n) => {\n  \"worklet\";\n  const path = {\n    move: {\n      x: interpolate(\n        value,\n        inputRange,\n        outputRange.map((p) => p.move.x),\n        extrapolate\n      ),\n      y: interpolate(\n        value,\n        inputRange,\n        outputRange.map((p) => p.move.y),\n        extrapolate\n      ),\n    },\n    curves: outputRange[0].curves.map((_, index) => ({\n      c1: {\n        x: interpolate(\n          value,\n          inputRange,\n          outputRange.map((p) => p.curves[index].c1.x),\n          extrapolate\n        ),\n        y: interpolate(\n          value,\n          inputRange,\n          outputRange.map((p) => p.curves[index].c1.y),\n          extrapolate\n        ),\n      },\n      c2: {\n        x: interpolate(\n          value,\n          inputRange,\n          outputRange.map((p) => p.curves[index].c2.x),\n          extrapolate\n        ),\n        y: interpolate(\n          value,\n          inputRange,\n          outputRange.map((p) => p.curves[index].c2.y),\n          extrapolate\n        ),\n      },\n      to: {\n        x: interpolate(\n          value,\n          inputRange,\n          outputRange.map((p) => p.curves[index].to.x),\n          extrapolate\n        ),\n        y: interpolate(\n          value,\n          inputRange,\n          outputRange.map((p) => p.curves[index].to.y),\n          extrapolate\n        ),\n      },\n    })),\n    close: outputRange[0].close,\n  };\n  return serialize(path);\n};\n\n/**\n * @summary Interpolate two paths with an animation value that goes from 0 to 1\n */\nexport const mixPath = (\n  value: number,\n  p1: Path,\n  p2: Path,\n  extrapolate = Animated.Extrapolate.CLAMP\n) => {\n  \"worklet\";\n  return interpolatePath(value, [0, 1], [p1, p2], extrapolate);\n};\n\n/**\n * @summary Create a new path\n */\nexport const createPath = (move: Vector): Path => {\n  \"worklet\";\n  return {\n    move,\n    curves: [],\n    close: false,\n  };\n};\n\n/**\n * @summary Add an arc command to a path\n */\nexport const addArc = (path: Path, corner: Vector, to: Vector) => {\n  \"worklet\";\n  const last = path.curves[path.curves.length - 1];\n  const from = last ? last.to : path.move;\n  const arc = 9 / 16;\n  path.curves.push({\n    c1: {\n      x: (corner.x - from.x) * arc + from.x,\n      y: (corner.y - from.y) * arc + from.y,\n    },\n    c2: {\n      x: (corner.x - to.x) * arc + to.x,\n      y: (corner.y - to.y) * arc + to.y,\n    },\n    to,\n  });\n};\n\n/**\n * @summary Add a cubic Bèzier curve command to a path.\n */\nexport const addCurve = (path: Path, c: Curve) => {\n  \"worklet\";\n  path.curves.push({\n    c1: c.c1,\n    c2: c.c2,\n    to: c.to,\n  });\n};\n\n/**\n * @summary Add a line command to a path.\n */\nexport const addLine = (path: Path, to: Vector) => {\n  \"worklet\";\n  const last = path.curves[path.curves.length - 1];\n  const from = last ? last.to : path.move;\n  path.curves.push({\n    c1: from,\n    c2: to,\n    to,\n  });\n};\n\n/**\n * @summary Add a quadratic Bèzier curve command to a path.\n */\nexport const addQuadraticCurve = (path: Path, cp: Vector, to: Vector) => {\n  \"worklet\";\n  const last = path.curves[path.curves.length - 1];\n  const from = last ? last.to : path.move;\n  path.curves.push({\n    c1: {\n      x: from.x / 3 + (2 / 3) * cp.x,\n      y: from.y / 3 + (2 / 3) * cp.y,\n    },\n    c2: {\n      x: to.x / 3 + (2 / 3) * cp.x,\n      y: to.y / 3 + (2 / 3) * cp.y,\n    },\n    to,\n  });\n};\n\n/**\n * @summary Add a close command to a path.\n */\nexport const close = (path: Path) => {\n  \"worklet\";\n  path.close = true;\n};\n\ninterface SelectedCurve {\n  from: Vector;\n  curve: Curve;\n}\n\ninterface NullableSelectedCurve {\n  from: Vector;\n  curve: Curve | null;\n}\n\nconst curveIsFound = (c: NullableSelectedCurve): c is SelectedCurve => {\n  \"worklet\";\n  return c.curve !== null;\n};\n\n/**\n * @summary Return the curves at x. This function assumes that only one curve is available at x\n */\nexport const selectCurve = (path: Path, x: number): SelectedCurve => {\n  \"worklet\";\n  const result: NullableSelectedCurve = {\n    from: path.move,\n    curve: null,\n  };\n  for (let i = 0; i < path.curves.length; i++) {\n    const c = path.curves[i];\n    const contains =\n      result.from.x > c.to.x\n        ? x >= c.to.x && x <= result.from.x\n        : x >= result.from.x && x <= c.to.x;\n    if (contains) {\n      result.curve = c;\n      break;\n    }\n    result.from = c.to;\n  }\n  if (!curveIsFound(result)) {\n    throw new Error(`No curve found at ${x}`);\n  }\n  return result;\n};\n\n/**\n * @summary Return the y value of a path given its x coordinate\n * @example\n    const p1 = parse(\n      \"M150,0 C150,0 0,75 200,75 C75,200 200,225 200,225 C225,200 200,150 0,150\"\n    );\n    // 75\n    getYForX(p1, 200))\n    // ~151\n    getYForX(p1, 50)\n */\nexport const getYForX = (path: Path, x: number, precision = 2) => {\n  \"worklet\";\n  const c = selectCurve(path, x);\n  return cubicBezierYForX(\n    x,\n    c.from,\n    c.curve.c1,\n    c.curve.c2,\n    c.curve.to,\n    precision\n  );\n};\n\nconst controlPoint = (\n  current: Vector,\n  previous: Vector,\n  next: Vector,\n  reverse: boolean,\n  smoothing: number\n) => {\n  \"worklet\";\n  const p = previous || current;\n  const n = next || current;\n  // Properties of the opposed-line\n  const lengthX = n.x - p.x;\n  const lengthY = n.y - p.y;\n\n  const o = cartesian2Polar({ x: lengthX, y: lengthY });\n  // If is end-control-point, add PI to the angle to go backward\n  const angle = o.theta + (reverse ? Math.PI : 0);\n  const length = o.radius * smoothing;\n  // The control point position is relative to the current point\n  const x = current.x + Math.cos(angle) * length;\n  const y = current.y + Math.sin(angle) * length;\n  return { x, y };\n};\n\nconst exhaustiveCheck = (a: never): never => {\n  throw new Error(`Unexhaustive handling for ${a}`);\n};\n\n/**\n * @summary Link points via a smooth cubic Bézier curves\n * from https://github.com/rainbow-me/rainbow\n */\nexport const curveLines = (\n  points: Vector<number>[],\n  smoothing: number,\n  strategy: \"complex\" | \"bezier\" | \"simple\"\n) => {\n  \"worklet\";\n  const path = createPath(points[0]);\n  // build the d attributes by looping over the points\n  for (let i = 0; i < points.length; i++) {\n    if (i === 0) {\n      continue;\n    }\n    const point = points[i];\n    const next = points[i + 1];\n    const prev = points[i - 1];\n    const cps = controlPoint(prev, points[i - 2], point, false, smoothing);\n    const cpe = controlPoint(point, prev, next, true, smoothing);\n    switch (strategy) {\n      case \"simple\":\n        const cp = {\n          x: (cps.x + cpe.x) / 2,\n          y: (cps.y + cpe.y) / 2,\n        };\n        addQuadraticCurve(path, cp, point);\n        break;\n      case \"bezier\":\n        const p0 = points[i - 2] || prev;\n        const p1 = points[i - 1];\n        const cp1x = (2 * p0.x + p1.x) / 3;\n        const cp1y = (2 * p0.y + p1.y) / 3;\n        const cp2x = (p0.x + 2 * p1.x) / 3;\n        const cp2y = (p0.y + 2 * p1.y) / 3;\n        const cp3x = (p0.x + 4 * p1.x + point.x) / 6;\n        const cp3y = (p0.y + 4 * p1.y + point.y) / 6;\n        path.curves.push({\n          c1: { x: cp1x, y: cp1y },\n          c2: { x: cp2x, y: cp2y },\n          to: { x: cp3x, y: cp3y },\n        });\n        if (i === points.length - 1) {\n          path.curves.push({\n            to: points[points.length - 1],\n            c1: points[points.length - 1],\n            c2: points[points.length - 1],\n          });\n        }\n        break;\n      case \"complex\":\n        path.curves.push({\n          to: point,\n          c1: cps,\n          c2: cpe,\n        });\n        break;\n      default:\n        exhaustiveCheck(strategy);\n    }\n  }\n  return path;\n};\n"]},"metadata":{},"sourceType":"module"}